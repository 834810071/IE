## [vivo提前批武汉站C++后端面经](https://www.nowcoder.com/discuss/197908)

### 1. linux中查询一个文件第三列并按顺序显示

```
cat filename | awk '{print $1 }' // 第一列
cat filename | awk 'NR==1' // 第一行
```

### 2.const，static，volatile

### [const](https://interview.huihut.com/#/?id=const)

#### [作用](https://interview.huihut.com/#/?id=作用)

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针和指针常量；
3. 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。
5. 指向常量的指针：const int * a；int const *a； 常量指针int *const a；

### [static](https://interview.huihut.com/#/?id=static)

#### [作用](https://interview.huihut.com/#/?id=作用-1)

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

### [volatile](https://interview.huihut.com/#/?id=volatile)

```cpp
volatile int i = 10; 
```

- **不可优化性.** volatile 关键字是一种类型修饰符，用它声明的类型变量表示不可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
- **易变性.**volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile

### 3. 内存对齐

### 一、什么是内存对齐

**内存对齐（Memory alignment）**，也叫字节对齐。

现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。

### 二、为什么要内存对齐

之所以要内存对齐，有两方面的原因：

- **平台原因**：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。————- 比如，有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。
- **性能原因**：内存对齐可以提高存取效率。————- 比如，有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。

参考:[C/C++内存对齐](https://songlee24.github.io/2014/09/20/memory-alignment/)

### 4.模板的编译过程

​	当编译器遇到一个template时，不能够立马为他产生机器代码，它必须等到template被指定某种类型。也就是说，函数模板和类模板的完整定义将出现在template被使用的每一个角落.