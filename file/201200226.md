## [字节跳动rust/c++实习面经](https://www.nowcoder.com/discuss/201045)

### [1.合并k个有序数组](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```c
// 效率不高
/**

 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* res = nullptr;
        if (lists.size() == 0) {
            return res;
        }

        for (int i = 0; i < lists.size(); ++i) {
            res = merge(res, lists[i]);
        }
        return res;
    }

    ListNode* merge(ListNode* l, ListNode* r) {
        ListNode* res = new ListNode(0);
        ListNode* cur = res;
        while (l && r) {
            if (l->val >= r->val) {
                cur->next = r;
                cur = cur->next;
                r = r->next;
            } else {
                cur->next = l;
                cur = cur->next;
                l = l->next;
            }
        }
        while (r) {
            cur->next = r;
            cur = cur->next;
            r = r->next;
        }

        while (l) {
            cur->next = l;
                cur = cur->next;
                l = l->next;
        }
        return res->next;
    }
};
```

```c
// 分治法
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return NULL;
        int n = lists.size();
        while (n > 1) {
            int k = (n + 1) / 2;
            for (int i = 0; i < n / 2; ++i) {
                lists[i] = mergeTwoLists(lists[i], lists[i + k]);
            }
            n = k;
        }
        return lists[0];
    }
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *dummy = new ListNode(-1), *cur = dummy;
        while (l1 && l2) {
            if (l1->val < l2->val) {
                cur->next = l1;
                l1 = l1->next;
            } else {
                cur->next = l2;
                l2 = l2->next;
            }
            cur = cur->next;
        }
        if (l1) cur->next = l1;
        if (l2) cur->next = l2;
        return dummy->next;
    }
};
```

## [2.一个整数分解为多个不同的数之和，有几种分法](https://www.cnblogs.com/ibilllee/p/7655317.html)

```c
此类问题有如下几种形态：

1. 将n划分成若干正整数之和的划分数。
2. 将n划分成k个正整数之和的划分数。
3. 将n划分成最大数不超过k的划分数。
4. 将n划分成若干奇正整数之和的划分数。
5. 将n划分成若干不同整数之和的划分数。

 

1:将n划分成若干正整数的划分数

(1):划分数可以存在相同的数

那么，设dp[n][m]表示整数 n 的划分中，每个数不大于 m 的划分数。

则划分数可以分为两种情况:
　　a.划分中每个数都小于 m，相当于每个数不大于 m- 1, 故划分数为 dp[n][m-1]
　　b.划分中有一个数为 m. 那就在 n中减去 m ,剩下的就相当于把 n-m 进行划分， 故划分数为 dp[n-m][m]

总递推式：dp[n][m]=dp[n][m-1]+dp[n-m][m]

(2):划分数不可以存在相同的数

若还是设成同样的状态，从（1）可以看出，a条件是不会改变的，而b条件中，n-m后由于不存在重复，则划分数变为dp[n-m][m-1]

总递推式：dp[n][m]=dp[n][m-1]+dp[n-m][m-1]

 

2:将n划分成k个正整数的划分数

设dp[i][k]为，把i分成k分的划分法

那么也有两种情况：

　　a.n份中不包括1的情况，那么每份中都可以拿出1来，即为dp[i-k][k]

　　b.n份中起码有1个1的情况，那么把这个1去掉，变为dp[i-1][k-1]

总递推式：dp[i][k]=dp[i-k][k]+dp[i-1][k-1]

 

3:将n划分成若干奇数的划分数

设g[i][j]:将i划分成j个偶数

f[i][j]:将i划分成j个奇数

对于偶数来讲，为f[i-j][j]中的共j个数，每个加1，则变成偶数。

对于奇数来讲，为g[i-j][j]中的共j个数，每个加1，则变成奇数；且还有新加入的1，则为f[i-1][j-1]

所以递推式为：g[i][j]=f[i-j][j] , f[i][j]=f[i-1][j-1] + g[i-j][j]
```

```c
#define nmax 51
int num[nmax][nmax]; //将i划分为不大于j的个数
int num1[nmax][nmax]; //将i划分为不大于j的不同的数
int num2[nmax][nmax]; //将i划分为j个数
int f[nmax][nmax]; //将i划分为j个奇数
int g[nmax][nmax]; //将i划分为j个偶数
void init() {
    int i, j;
    for (i = 0; i < nmax; i++) {
        num[i][0] = 0, num[0][i] = 0, num1[i][0] = 0, num1[0][i] = 0, num2[i][0] =
                0, num2[0][i] = 0;
    }
    for (i = 1; i < nmax; i++) {
        for (j = 1; j < nmax; j++) {
            if (i < j) {
                num[i][j] = num[i][i];
                num1[i][j] = num1[i][i];
                num2[i][j] = 0;
            } else if (i == j) {
                num[i][j] = num[i][j - 1] + 1;
                num1[i][j] = num1[i][j - 1] + 1;
                num2[i][j] = 1;

            } else {
                num[i][j] = num[i][j - 1] + num[i - j][j];
                num1[i][j] = num1[i][j - 1] + num1[i - j][j - 1];
                num2[i][j] = num2[i - 1][j - 1] + num2[i - j][j];
            }
        }
    }
    f[0][0] = 1, g[0][0] = 1;
    for (i = 1; i < nmax; i++) {
        for (j = 1; j <= i; j++) {
            g[i][j] = f[i - j][j];
            f[i][j] = f[i - 1][j - 1] + g[i - j][j];
        }
    }
}
```

**参考**： [将一个整数划分为多个正整数之和](https://blog.csdn.net/woniu317/article/details/39250403)

## 3.介绍一下cpp的智能指针

### [智能指针](https://interview.huihut.com/#/?id=智能指针)

#### [C++ 标准库（STL）中](https://interview.huihut.com/#/?id=c-标准库（stl）中)

头文件：`#include <memory> `

#### [C++ 98](https://interview.huihut.com/#/?id=c-98)

```cpp
std::auto_ptr<std::string> ps (new std::string(str))；
```

#### [C++ 11](https://interview.huihut.com/#/?id=c-11)

1. shared_ptr
2. unique_ptr
3. weak_ptr
4. auto_ptr（被 C++11 弃用）

- Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。
- Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。

##### [shared_ptr](https://interview.huihut.com/#/?id=shared_ptr)

多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。

- 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁

##### [weak_ptr](https://interview.huihut.com/#/?id=weak_ptr)

weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。

- 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

##### [unique_ptr](https://interview.huihut.com/#/?id=unique_ptr)

unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

- unique_ptr 用于取代 auto_ptr

##### [auto_ptr](https://interview.huihut.com/#/?id=auto_ptr)

被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 `std::move` 语义，以及其他瑕疵。

##### [auto_ptr 与 unique_ptr 比较](https://interview.huihut.com/#/?id=auto_ptr-与-unique_ptr-比较)

- auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了`move` 语义；
- auto_ptr 对象不能管理数组（析构调用 `delete`），unique_ptr 可以管理数组（析构调用 `delete[]` ）；

**参考**： [c++ 智能指针用法详解](https://www.cnblogs.com/TenosDoIt/p/3456704.html)

### [4. std::move](https://blog.csdn.net/p942005405/article/details/84644069)

###  5. extern c

### [extern "C"](https://interview.huihut.com/#/?id=extern-quotcquot)

- 被 extern 限定的函数或变量是 extern 类型的
- 被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的

`extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

extern "C" 使用

```cpp
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

参考：[C++项目中的extern "C" {}](https://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html)

### 6. TCP的重传机制

### 7. TCP的拥塞控制